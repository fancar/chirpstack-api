syntax = "proto3";

package api;

option go_package = "github.com/brocaar/chirpstack-api/go/v3/as/external/api";
option java_package = "io.chirpstack.api.as.external.api";
option java_multiple_files = true;
option java_outer_classname = "DeviceQueueProto";

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";


// DeviceQueueService is the service managing the downlink data queue.
service DeviceQueueService {
    // Enqueue adds the given item to the device-queue.
    rpc Enqueue(EnqueueDeviceQueueItemRequest) returns (EnqueueDeviceQueueItemResponse) {
        option(google.api.http) = {
            post: "/api/devices/{device_queue_item.dev_eui}/queue"
            body: "*"
        };
    }

    // EnqueueHex adds the given item to the device-queue with hex-payload.
    rpc EnqueueHex(EnqueueDeviceQueueItemHexRequest) returns (EnqueueDeviceQueueItemResponse) {
        option(google.api.http) = {
            post: "/api/devices/{dev_eui}/queue_hex"
            body: "*"
        };
    }

    // Flush flushes the downlink device-queue.
    rpc Flush(FlushDeviceQueueRequest) returns (google.protobuf.Empty) {
        option(google.api.http) = {
            delete: "/api/devices/{dev_eui}/queue"
        };
    }

    // List lists the items in the device-queue.
    rpc List(ListDeviceQueueItemsRequest) returns (ListDeviceQueueItemsResponse) {
        option(google.api.http) = {
            get: "/api/devices/{dev_eui}/queue"
        };
    }

    // ActilityEnqueue adds the given item to the device-queue with actility-styled request\response.
    rpc ActilityEnqueue(EnqueueDeviceQueueActilityItemRequest) returns (EnqueueDeviceQueueActilityItemResponse) {
        option(google.api.http) = {
            post: "/api/devices/{dev_eui}/queue/actilitystyle"
            body: "*"
        };
    }

    // GetNextDownlinkFCnt returns next downlink f-counter for the device
    // used by clients who encrypt payload data themself
    rpc GetNextDownlinkFCnt(GetNextDownlinkFCntRequest) returns (GetNextDownlinkFCntResponse) {
        option(google.api.http) = {
            get: "/api/devices/{dev_eui}/fcnt"
        };
    }    
}

message DeviceQueueItem {
    // Device EUI (HEX encoded).
    string dev_eui = 1 [json_name = "devEUI"];

    // Set this to true when an acknowledgement from the device is required.
    // Please note that this must not be used to guarantee a delivery.
    bool confirmed = 2;

    // Optional. Downlink frame-counter. Us it only if you encrypt payload byself!
    // By default=0, means it will be set to queue as is and encrypted right before send the dl.
    // Specify the excact next fCnt here. Otherwise it will be droped.
    // if fCnt>0 set, we send data as is, without encryption.
    uint32 f_cnt = 6;

    // FPort used (must be > 0)
    uint32 f_port = 3;

    // Base64 encoded data.
    // Or use the json_object field when an application codec has been configured.
    bytes data = 4;

    // Optional. JSON object (string).
    // Only use this when an application codec has been configured that can convert
    // this object into binary form.
    string json_object = 5;

    // Time to live (in seconds). You can specify the maximum time in queue for the item
    uint32 ttl = 7; 

    // Optional. the id will be generated on server side if empty
    // later on in case of error you'll recieve the message with the ID
    string message_id = 8;

    // Optional field
    string owner = 9;

    // service field for queue listing
    google.protobuf.Timestamp created_at = 10;

    // service field for queue listing
    google.protobuf.Timestamp timeout_after = 11;

    // id of the application. Optional. For validation purposes 
    uint32 application_id = 12 [json_name = "applicationID"];    
}

// DownlinkItemHex data payload as hex-string
message DownlinkItemHex {
    // Set this to true when an acknowledgement from the device is required.
    // Please note that this must not be used to guarantee a delivery.
    bool confirmed = 1;

    // Optional. Downlink frame-counter.
    // This will be automatically set on enquue.
    // If you encrypt data on your side - specify the fCnt here
    uint32 f_cnt = 2;

    // FPort used (must be > 0)
    uint32 f_port = 3;

    // hex-encoded string
    string data = 4;

    // Optional. Time to live (in seconds). You can specify the maximum time in queue for the item
    uint32 ttl = 5; 

    // Optional. the id will be generated on server side if empty
    // later on in case of error you'll recieve the message with the ID
    string message_id = 6;  
}

message EnqueueDeviceQueueItemHexRequest {
    // Device EUI (HEX encoded).
    string dev_eui = 1 [json_name = "dev_eui"];

    // Queue-item object to enqueue.
    DownlinkItemHex device_queue_item = 2;

    // ! CAUTION !
    // Set this to true ONLY if you really need to recieve the next fCnt 
    // (eg you want to know the enqueue-status immediately or in case of some development purposes)
    // ! Please do not call the method in parallel if the flag set it to true as
    // it can be painfully slow.
    // The flag basicaly means 'put the message right into the main queue'.
    // ! The next fCnt value be returned only if you set f_cnt parmeter. 
    // Otherwise it allways be 0.
    // If you set it to false it will be processed asynchronously via preprocessing queue.
    // In case of process with error later on it will sent the error as ErrorEvents via your integration.
    // You can match it by the message_id parameter.
    bool get_fcnt = 3;    
}

message EnqueueDeviceQueueItemRequest {
    // Queue-item object to enqueue.
    DeviceQueueItem device_queue_item = 1;

    // ! CAUTION !
    // Set this to true when you really need to recieve next fCnt 
    // or you want to know the enqueue-status immediately (eg development purposes)
    // ! Please do not call the method in parallel if the flag set it to true. 
    // It can be painfully slow.
    // The flag basicaly means 'put it right into queue'.
    // ! The next fCnt be returned only if you set f_cnt parmeter. 
    // Otherwise it allways be 0.
    // If you set it to false. It will be processed asynchronously.
    // In case of process with error - it will be sent as ErrorEvents via you apps.
    // You can match it by the message_id parameter.
    bool get_fcnt = 2;    
}

message EnqueueDeviceQueueItemResponse {
    // Frame-counter for the enqueued payload.
    // it allways zero if get_fcnt in request is false
    uint32 f_cnt = 1;

    // downlink message ID (UUID string). ! Generated for background tasks !
    string msg_id = 2;    
}

message FlushDeviceQueueRequest {
    // Device EUI (HEX encoded).
    string dev_eui = 1 [json_name = "dev_eui"];
}

message ListDeviceQueueItemsRequest {
    // Device EUI (HEX encoded).
    string dev_eui = 1 [json_name = "dev_eui"];

    // Return only the count, not the result-set.
    bool count_only = 2;
}

message ListDeviceQueueItemsResponse {
    // The device queue items.
    repeated DeviceQueueItem device_queue_items = 1;

    // Total number of items in the queue.
    uint32 total_count = 2;
}


message EnqueueDeviceQueueActilityItemRequest {
    // Device EUI (HEX encoded).
    string dev_eui = 1 [json_name = "dev_eui"];

    // Set this to true when an acknowledgement from the device is required.
    // Please note that this must not be used to guarantee a delivery.
    bool confirm_downlink = 2;

    // Indicates to flush the LRC downlink queue before adding the new message to the queue.
    // Default is false.
    bool flush_downlink_queue = 3;

    // Payload of the message in hexadecimal format.
    string payload_hex = 4;

    // LoRa port(s) targetted by the message.
    string target_ports = 5;

    // Downlink frame-counter.
    // This will be automatically set on enquue.
    // If you encrypt data on your side - specify the fCnt here
    uint32 f_cnt = 6;

    // Time to live (in seconds). You canspecify the maximum time in queue for the item
    uint32 ttl = 7;

    // ! CAUTION !
    // Set this to true when you really need to recieve next fCnt 
    // or you want to know the enqueue-status immediately (eg development purposes)
    // ! Please do not call the method in parallel if the flag set it to true. 
    // It can be painfully slow.
    // The flag basicaly means 'put it right into queue'.
    // ! The next fCnt be returned only if you set f_cnt parmeter. 
    // Otherwise it allways be 0.
    // If you set it to false. It will be processed asynchronously.
    // In case of process with error - it will be sent as ErrorEvents via you apps.
    // You can match it by the message_id parameter.
    bool get_fcnt = 8;    
}

message EnqueueDeviceQueueActilityItemResponse {
    // Frame-counter for the enqueued payload.
    bool confirm_downlink = 1;
    bool flush_downlink_queue = 2;
    string payload_hex = 3;
    string target_ports = 4;
    string status = 5;

    // downlink message ID (UUID string). ! Generated for background tasks !
    string msg_id = 6;       
}

message GetNextDownlinkFCntRequest {
    // Device EUI (HEX encoded).
    string dev_eui = 1 [json_name = "dev_eui"];
}

message GetNextDownlinkFCntResponse {
    // Next downlink frame-counter.
    uint32 f_cnt = 1;
}  
